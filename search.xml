<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ScalikeJDBC 公共化使用</title>
      <link href="/2019/01/23/scalikejdbc_01/"/>
      <url>/2019/01/23/scalikejdbc_01/</url>
      
        <content type="html"><![CDATA[<h3 id="about-scalikeJdbc"><a href="#about-scalikeJdbc" class="headerlink" title="about scalikeJdbc"></a>about scalikeJdbc</h3><p>ScalikeJDBC是为Scala开发人员提供的一个整洁的基于sql的DB访问库，关于scalikejdbc的使用不在做过多的说明，在下面放出scalikeJdbc 官网。本文着重介绍如何将scalikejdbc 的API进行公共化，做到和其他java持久化组件一样，每次开发持久层只要写少量的代码，减少冗余。<br><a href="http://scalikejdbc.org/" target="_blank" rel="noopener">http://scalikejdbc.org/</a></p><h6 id="scalikeJdbc-批量插入源码与公共化"><a href="#scalikeJdbc-批量插入源码与公共化" class="headerlink" title="scalikeJdbc 批量插入源码与公共化"></a>scalikeJdbc 批量插入源码与公共化</h6><p>1、先让我们看一下如何使用batch接口：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scalikejdbc._</span><br><span class="line"></span><br><span class="line"><span class="type">DB</span> localTx &#123; <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">  <span class="keyword">val</span> batchParams: <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">Any</span>]] = (<span class="number">2001</span> to <span class="number">3000</span>).map(i =&gt; <span class="type">Seq</span>(i, <span class="string">"name"</span> + i))</span><br><span class="line">  <span class="string">sql"insert into emp (id, name) values (?, ?)"</span>.batch(batchParams: _*).apply()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DB</span> localTx &#123; <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">  <span class="string">sql"insert into emp (id, name) values (&#123;id&#125;, &#123;name&#125;)"</span></span><br><span class="line">    .batchByName(<span class="type">Seq</span>(<span class="type">Seq</span>(<span class="symbol">'id</span> -&gt; <span class="number">1</span>, <span class="symbol">'name</span> -&gt; <span class="string">"Alice"</span>), <span class="type">Seq</span>(<span class="symbol">'id</span> -&gt; <span class="number">2</span>, <span class="symbol">'name</span> -&gt; <span class="string">"Bob"</span>)):_*)</span><br><span class="line">    .apply()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果想批量插入数据，需要定义一个Seq[Seq[Any]]类型的变量，在batch方法中会将该变量打平当成可变参数传入。batch方法同时需要在<strong>sql””</strong> 后面才能调用。如果想要通过参数名精确定位某个入参需要传入以’var_name -&gt; value的方式，我们需要搞清楚这些传入值是什么类型如何把他们以公共的方式提取出来，方便之后调用。</p><p>2、接下来我们来看一下源码，看一下底层是如何进行调用的：<br>首先我们点进batch方法找到<strong>sql””</strong> 的类型</p><p>scalikejdbc/SQL.scala</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch</span></span>(parameters: <span class="type">Seq</span>[<span class="type">Any</span>]*): <span class="type">SQLBatch</span> = &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">SQLBatch</span>(statement, parameters, tags)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里new了一个SQLBatch对象，并将已经初始化好的statement和可变参传入。找到方法所在类，看到是一个抽象类, 类名为SQL</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SQL</span>[<span class="type">A</span>, <span class="type">E</span> &lt;: <span class="type">WithExtractor</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">  val statement: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">  private[scalikejdbc] val rawParameters: <span class="type">Seq</span>[<span class="type">Any</span>]</span></span></span><br><span class="line"><span class="class"><span class="params"></span>)(<span class="params">f: <span class="type">WrappedResultSet</span> =&gt; <span class="type">A</span></span>)</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Extractor</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">batch</span></span>(parameters: <span class="type">Seq</span>[<span class="type">Any</span>]*): <span class="type">SQLBatch</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">SQLBatch</span>(statement, parameters, tags)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再点进 <strong><em>sql””</em></strong> 进入SQLInterpolationString类，可以看到返回的正是实例化的SQL类，并且还调用了SQL类的bind方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLInterpolationString</span>(<span class="params">val s: <span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> scalikejdbc.interpolation.<span class="type">SQLSyntax</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sql</span></span>[<span class="type">A</span>](params: <span class="type">Any</span>*): <span class="type">SQL</span>[<span class="type">A</span>, <span class="type">NoExtractor</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> syntax = sqls(params: _*)</span><br><span class="line">    <span class="type">SQL</span>[<span class="type">A</span>](syntax.value).bind(syntax.rawParameters: _*)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ..........</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>这时我们可以确定 <strong><em>sql””</em></strong> 是一个SQL类的实例。这时我们就可以定义我们的第一个公共方法，批量插入。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batchInsert</span></span>( sql:<span class="type">SQL</span>[<span class="type">Nothing</span>, <span class="type">NoExtractor</span>],params:<span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">Any</span>]] ): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="type">DB</span> localTx &#123; <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">    sql.batch(params: _*).apply()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将可变参和SQL实例提取出来，做为变量传入。调用如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">bacthInsert</span></span>(list: <span class="type">ListBuffer</span>[<span class="type">Seq</span>[<span class="type">Any</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> sql= <span class="string">sql"REPLACE into dept (dept_name , num ) VALUES(?,?)"</span>;</span><br><span class="line">  db.batchInsert(sql,list.toSeq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以很方便的调用了，每次只需要写与业务逻辑相关的sql即可</p><p>3、我们继续把按名称变量插入方法进行公共化，需要知道 <strong><em>‘var_name</em></strong> 的类型，点进batchName查看代码：</p><p>scalikejdbc/SQL.scala</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Binds parameters for batch</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param parameters parameters</span></span><br><span class="line"><span class="comment">   * @return SQL for batch</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">batchByName</span></span>(parameters: <span class="type">Seq</span>[(<span class="type">Symbol</span>, <span class="type">Any</span>)]*): <span class="type">SQLBatch</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> _sql = validateAndConvertToNormalStatement(statement, _settings, parameters.headOption.getOrElse(<span class="type">Seq</span>.empty))._1</span><br><span class="line">    <span class="keyword">val</span> _parameters: <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">Any</span>]] = parameters.map &#123; p =&gt;</span><br><span class="line">      validateAndConvertToNormalStatement(statement, _settings, p)._2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">SQLBatch</span>(_sql, _parameters, tags)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到接收参数为一个可变参数类型为Seq[(Symbol, Any)] 一个Seq里包含了一个Tuple。同样是new了一个SQLBatch类的实例。我们根据之前的batch方法很快就又得到一个公共方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">batchByNameInsert</span></span>( sql:<span class="type">SQL</span>[<span class="type">Nothing</span>, <span class="type">NoExtractor</span>],params:<span class="type">Seq</span>[<span class="type">Seq</span>[(<span class="type">Symbol</span>, <span class="type">Any</span>)]] ): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="type">DB</span> localTx &#123; <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">      sql.batchByName(params: _*).apply()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bacthInsertByName</span></span>(list: <span class="type">ListBuffer</span>[<span class="type">Seq</span>[(<span class="type">Symbol</span>, <span class="type">Any</span>)]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> sqlStr=<span class="string">sql"REPLACE INTO dept(dept_name,num) values(&#123;dept_name&#125;,&#123;num&#125;)"</span></span><br><span class="line">   db.batchByNameInsert(sqlStr,list.toSeq)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="scalikeJdbc-查询接口源码与公共化"><a href="#scalikeJdbc-查询接口源码与公共化" class="headerlink" title="scalikeJdbc 查询接口源码与公共化"></a>scalikeJdbc 查询接口源码与公共化</h6><p>同样我们先看一下查询api的使用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">DB</span> readOnly &#123; <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">  <span class="string">sql"select name from emp"</span>.map(rs =&gt; rs.string(<span class="string">"name"</span>)).list.apply()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询提供map方法可以将结果取出并转成所需要的对象以list输出。</p><p>我们来看一下map方法的接受的类型是什么：</p><p>scalikejdbc/SQL.scala</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps values from each [[scalikejdbc.WrappedResultSet]] object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param f extractor function</span></span><br><span class="line"><span class="comment"> * @tparam A return type</span></span><br><span class="line"><span class="comment"> * @return SQL instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>](f: <span class="type">WrappedResultSet</span> =&gt; <span class="type">A</span>): <span class="type">SQL</span>[<span class="type">A</span>, <span class="type">HasExtractor</span>] = &#123;</span><br><span class="line">  withExtractor[<span class="type">A</span>](f).fetchSize(fetchSize).tags(tags: _*).queryTimeout(queryTimeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收一个匿名函数作为入参 （f: WrappedResultSet =&gt; A），同样返回的是一个SQL类的实例，这样我们就知道该如何定义我们需要的方法了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queryAll</span></span>[<span class="type">A</span>](sql:<span class="type">SQL</span>[<span class="type">Nothing</span>, <span class="type">NoExtractor</span>],f: <span class="type">WrappedResultSet</span> =&gt; <span class="type">A</span>) =&#123;</span><br><span class="line">   <span class="type">DB</span> readOnly &#123; <span class="keyword">implicit</span> session=&gt;</span><br><span class="line">     sql.map(f).list().apply()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用的时候，我们只需要根据每个sql的结果自定义匿名函数即可：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queryAll</span></span>(): <span class="type">List</span>[<span class="type">RiskWord</span>] =&#123;</span><br><span class="line">    <span class="keyword">val</span> sql = <span class="string">sql"select id,dt,word,count_num from risk_word"</span></span><br><span class="line">    db.queryAll(sql,</span><br><span class="line">      rs=&gt;&#123;</span><br><span class="line">        <span class="type">RiskWord</span>(rs.int(<span class="string">"id"</span>),</span><br><span class="line">          rs.date(<span class="string">"dt"</span>),</span><br><span class="line">          rs.string(<span class="string">"word"</span>),</span><br><span class="line">          rs.long(<span class="string">"count_num"</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本文对scalike JDBC的几个Operation进行了公共化，scalike还提供了许多方法可以依照上文方法进行公共化。本文也对scalike JDBC的源码做了初步了解知道了每次调用的SQL对象是如何初始化的，接下来需要对scalike源码中参数如何进行绑定sql以及每次调用的详细流程进行了解。</p><p>最后附上以上代码的git地址：<br><a href="https://github.com/duskGeek/geek/blob/master/geek-utils/src/main/scala/com/geek/utils/mysql/DBOperations.scala" target="_blank" rel="noopener">https://github.com/duskGeek/geek/blob/master/geek-utils/src/main/scala/com/geek/utils/mysql/DBOperations.scala</a></p><ul><li>scala</li><li>ScalikeJdbc</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> scala </tag>
            
            <tag> ScalikeJDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark</title>
      <link href="/2017/05/13/spark/"/>
      <url>/2017/05/13/spark/</url>
      
        <content type="html"><![CDATA[<h3 id="spark-web"><a href="#spark-web" class="headerlink" title="spark web"></a>spark web</h3><p><a href="http://spark.apache.org/docs/" target="_blank" rel="noopener">spark官网</a></p><h3 id="spark-demo-code"><a href="#spark-demo-code" class="headerlink" title="spark demo code"></a>spark demo code</h3><p>First, we import the names of the Spark Streaming classes and some implicit conversions from StreamingContext into our environment in order to add useful methods to other classes we need (like DStream). StreamingContext is the main entry point for all streaming functionality. We create a local StreamingContext with two execution threads, and a batch interval of 1 second.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.<span class="type">StreamingContext</span>._ <span class="comment">// not necessary since Spark 1.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a local StreamingContext with two working thread and batch interval of 1 second.</span></span><br><span class="line"><span class="comment">// The master requires 2 cores to prevent a starvation scenario.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"NetworkWordCount"</span>)</span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h4 id="Spark-img"><a href="#Spark-img" class="headerlink" title="Spark img"></a>Spark img</h4><p><img src="/img/blog_img/streaming-dstream-ops.png" alt="avatar"></p><ul><li>spark-core</li><li>spark streaming</li><li>spark sql</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
